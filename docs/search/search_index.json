{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to the linearmoney library's documentation!","text":"<p>linearmoney is a library for working with multiple currencies that uses a non-traditional model based on linear algebra to allow lossless currency conversion and calculations with multiple currencies simultaneously.</p> <p>Understanding of linear algebra is not required to use the linearmoney library, and the library is designed in such a way that the same code can be used for single and multi-currency calculations, so the programmer no longer has to worry about keeping track of individual currencies, and in most cases, doesn't even need to know which currency a particular value is in. This makes developing modern international applications much simpler.</p> <p>Currencies can be easily converted based on exchange rates, and full localization support is built-in.</p> <p>The linearmoney library uses a completely thread-safe functional/procedural style that is verbose but very clear in its behavior with no mutable data or side effects.</p> <p>This makes it ideal for other library/framework authors to use for core currency functionalities while providing a higher level API for use by end-users, but application developers can still use the library directly if they prefer as all of the core functionalities of a monetary application are provided (conversion, localization/formatting, rates/data management).</p>"},{"location":"index.html#basic-usage","title":"Basic Usage","text":"<pre><code>pip install linearmoney\n</code></pre> <pre><code>&gt;&gt;&gt; import linearmoney as lm\n&gt;&gt;&gt; fo = lm.vector.forex({\"base\": \"usd\", \"rates\": {\"jpy\": 100}})  # 1 USD -&gt; 100 JPY\n&gt;&gt;&gt; sp = lm.vector.space(fo)\n&gt;&gt;&gt; cart = []\n&gt;&gt;&gt; local_milk_price = lm.vector.asset(4.32, \"usd\", sp)\n&gt;&gt;&gt; cart.append(local_milk_price)\n&gt;&gt;&gt; foreign_eggs_price = lm.vector.asset(545, \"jpy\", sp)\n&gt;&gt;&gt; cart.append(foreign_eggs_price)\n&gt;&gt;&gt; sales_tax = 0.095\n&gt;&gt;&gt; subtotal = sum(cart)\n&gt;&gt;&gt; total = subtotal + (subtotal * sales_tax)\n&gt;&gt;&gt; total_usd = lm.vector.evaluate(total, \"usd\", fo)\n&gt;&gt;&gt; total_jpy = lm.vector.evaluate(total, \"jpy\", fo)\n&gt;&gt;&gt; usd = lm.data.currency(\"usd\")\n&gt;&gt;&gt; jpy = lm.data.currency(\"jpy\")\n&gt;&gt;&gt; rounded_total_usd = lm.scalar.roundas(total_usd, usd)\n&gt;&gt;&gt; rounded_total_jpy = lm.scalar.roundas(total_jpy, jpy)\n&gt;&gt;&gt; en_US = lm.data.locale(\"en\", \"us\")\n&gt;&gt;&gt; localized_total_usd = lm.scalar.l10n(rounded_total_usd, usd, en_US)\n&gt;&gt;&gt; localized_total_jpy = lm.scalar.l10n(rounded_total_jpy, jpy, en_US)\n&gt;&gt;&gt; print(localized_total_usd)\n$10.70\n&gt;&gt;&gt; print(localized_total_jpy)\n\u00a51,070\n</code></pre>"},{"location":"FAQ.html","title":"linearmoney Frequently Asked Questions","text":""},{"location":"FAQ.html#what-is-the-meaning-of-life-the-universe-and-everything","title":"What is the meaning of life, the universe, and everything?","text":"<p>42</p>"},{"location":"FAQ.html#what-are-the-recommended-import-conventions","title":"What are the recommended import conventions?","text":"<ul> <li>The top-level package should be imported using a numpy-style short alias.<ul> <li><code>import linearmoney as lm</code></li> </ul> </li> <li>Functions should not be imported directly, and instead should be called as members of the containing module's namespace.<ul> <li><code>lm.vector.dot()</code></li> <li><code>lm.data.currency()</code></li> </ul> </li> <li>Identifiers that are primarily used as a type (Classes, Exceptions, etc...) should be imported and used directly.<ul> <li><code>from linearmoney.exceptions import IntegrityError</code></li> <li><code>from linearmoney.vectors import ForexVector</code></li> </ul> </li> </ul>"},{"location":"glossary.html","title":"Glossary of Terms","text":"<p>This is a quick reference for terms used throughout the linearmoney source and docs. documentation and  source code.</p>"},{"location":"glossary.html#money-vector","title":"Money Vector","text":"<p>Used to refer to any vector used in linear money calculations. Includes both asset and forex vectors.</p>"},{"location":"glossary.html#asset-vector","title":"Asset Vector","text":"<p>An asset vector is a vector that represents a monetary amount in one or more currencies simultaneously.</p> <p>This is the closest thing to the traditional Money type in most currency frameworks.</p> <p>Asset vectors should be constructed via the <code>asset</code> function of the <code>vector</code> module.</p> <p>This is simply a conceptual distinction. Technically, there is no <code>AssetVector</code> type in the linearmoney library, and all Asset Vectors are actually of the <code>MoneyVector</code> type.</p>"},{"location":"glossary.html#rudimentary-asset","title":"Rudimentary Asset","text":"<p>An asset vector that contains a value for only one currency. In other words, all components of the vector except for one are 0, and evaluating the asset is equivalent to converting a traditional single-currency value.</p> <p>Rudimentary assets behave similarly to the traditional model of money that most people are used to, but being vectors, they still obey the same mathematical rules as more complex monetary amounts.</p>"},{"location":"glossary.html#composite-asset","title":"Composite Asset","text":"<p>An asset vector that contains a value for more than one currency.</p> <p>By representing these values as a vector, we are able to do arithmetic with other monetary values without losing any information about which currencies are involved.</p>"},{"location":"glossary.html#forex-vector","title":"Forex Vector","text":"<p>A forex vector is a vector that represents the foreign exchange rates from every currency in its currency space to a specific currency in the same space.</p> <p>It does not matter which currency the rates in the forex vector correspond to as long as the vector contains all of the rates for its currency space.</p> <p>The <code>gamma</code> function is used to obtain a forex vector with the rates to a specific currency from any valid forex vector.</p> <p>Forex vectors should be constructed via the <code>forex</code> function of the <code>vector</code> module.</p>"},{"location":"glossary.html#evaluation","title":"Evaluation","text":"<p>Evaluation refers to the process of calculating the numeric value of a monetary amount in a specific currency. The amount can be in multiple different currencies and the evaluation will calculate the total value of all of the amount's currencies in the target currency.</p> <p>This process takes a vector and produces a number representing the total value of the vector in the target currency.</p>"},{"location":"glossary.html#conversion","title":"Conversion","text":"<p>Conversion refers to the process of converting a monetary amount from one currency to another and corresponds to the real-world process of exchanging a currency for another currency. The amount can be in multiple different currencies and the conversion will calculate the total value of all of the amount's currencies and convert to the target currency.</p> <p>This process takes a vector and produces another vector representing the total value of the original vector in the target currency only.</p>"},{"location":"glossary.html#precision-truncated","title":"Precision Truncated","text":"<p>Due to how python's decimal  module handles precision in certain operations, especially multiplication,  some calculations will result in cumulative rounding error even if the inputs  are simple monetary amounts already rounded to two decimal places (or whatever  is appropriate for the currency involved), so in these situations, linearmoney will discard a certain number of digits from the result starting at  the least significant bit in order to ensure that the result is consistent  accross multiple runs of the same calculation without losing any actual  precision, and this process is referred to in the documentation as precision  truncation.</p> <p>Also, it should be noted that this is done to ensure that common  operations such as equality comparisons give the correct results, in order to  uphold the principle of least astonishment, but this does not have any effect  on the correctness of any calculations.</p>"},{"location":"glossary.html#locale-tag","title":"Locale Tag","text":"<p>Locales in the linearmoney library are identified by the language and territory portion of the posix format, but do not include any encodings or other modifiers.</p> <p>Example: en_US for United States English.</p>"},{"location":"glossary.html#producer-function","title":"Producer Function","text":"<p>Producer functions are functions in the <code>data</code> module that return <code>Datasources</code> and are essential to the linearmoney library's state model.</p>"},{"location":"glossary.html#datasource","title":"Datasource","text":"<p>Datasources are Frozen dataclasses that define a store of data used by the linearmoney library for data-driven functional APIs. For example, formatting data used for localization.</p> <p>Datasources are created by producer functions, and they contain all of the information needed to be recreated exactly by another call to the producer function as follows:</p> <pre><code>producer(*datasource.id, **datasource.data)\n</code></pre> <p>This might seem useless, and being able to recreate an instance that we already hold a reference to isn't useful in itself, but the point is that all of the information needed for input is contained in the function's output. For immutable data-driven interfaces, this means that we have access to the entire program state in the return value of a function, which greatly simplifies state management in complex applications since we don't actually have to manage state, it's just there.</p>"},{"location":"linear_money_model.html","title":"A Linear-Algebraic Model for Monetary Data","text":"<p>Published: 01-Jan-2024  Update: 05-Jan-2024 - Style and Structure.</p> <p>View the update history for this article on GitHub.</p>"},{"location":"linear_money_model.html#author","title":"Author","text":"<p>Dalton Lang  @GrammAcc</p>"},{"location":"linear_money_model.html#abstract","title":"Abstract","text":"<p>Working with monetary data in a computer programming context is much more difficult than it should be, particularly when developing modern multi-currency applications for international users. The root cause of this is a fundamental misunderstanding of the mathematical properties of money among programmers, which stems from a lack of a formal mathematical definition of money itself. In this article, I will attempt to extrapolate the mathematical properties of money from its functional properties in order to make it easier to work with money programmatically and to be able to more reliably prove the correctness of financial calculations in general.</p> <p>I will gradually develop a purely mathematical model for working with monetary data to communicate the purpose of each piece and make the final iteration more intelligible. This will also serve to form an intuitive understanding of the mathematical properties of money that will make it easier to avoid pitfalls when performing monetary calculations.</p> <p>I will start by discussing the current best practices for working with currency programmatically and the difficulties that they present. The current practices are based on the foundational work by Martin Fowler, which I will use as a reference point and a foundation for the model to be developed, but my intention is not to discredit the work of Fowler and his colleagues at Thoughtworks or anyone else who has made contributions to the collective knowledge of our field. Nor is it to develop a pattern or framework to replace these ideas. My intention with this article is simply to identify and resolve a lack of clarity of the mathematical rules that underlie these patterns in order to simplify their implementation and maintenance in modern applications.</p>"},{"location":"linear_money_model.html#introduction","title":"Introduction","text":"<p>Traditional financial applications treat money as a simple data structure consisting of an amount and a currency. This is an intuitive representation of money, and it is certainly possible to build large scale financial applications based on this kind of structure since all modern financial infrastructure does so. However, this is a deceptively inaccurate representation of money with many pitfalls waiting for the unprepared. The reason for this is that this model only considers the intrinsic properties of money as an object, not its functional properties as, well, money.</p> <p>In order for an object to be used as money, it must satisfy three functional properties:</p> <ol> <li>Unit of account</li> <li>Medium of exchange</li> <li>Store of value</li> </ol> <p>Wikipedia has a lot of information on these properties and their history, but I will summarize them as they relate to our model.</p> <p>Medium of exchange is simple. We have to be able to exchange the monetary object for other arbitrary objects at some pre-determined rate.</p> <p>Store of value simply means that the object will still have value at some arbitrary point in the future. This might not seem like something that a mathematical model needs to worry about since it's more of a property of the physical object, but we will see later on that this is something we need to consider when creating a model that guarantees mathematical correctness of monetary calculations.</p> <p>Unit of account is also so simple it's not often thought about. It means that we have to be able to use units of the object in order to value other objects. This property is required in order for the object to be a medium of exchange or a store of value. This is because we can't exchange the object for another arbitrary object without valuing the other object in units of our medium. We also can't have value stored into the future unless we can value the object in terms of what we can exchange it for.</p> <p>The standard approach of simply pairing an amount with a currency only satisfies property #1. It ensures that we have a countable object, but it does nothing to indicate that we can exchange this object for something else or that it somehow retains value over time, and we are left to implement those details on our own.</p> <p>If we are to develop a mathematical model for working with monetary data, it must be able to encode all three of these properties at the mathematical level without any logical orchestration in code.</p>"},{"location":"linear_money_model.html#the-dilemma","title":"The Dilemma","text":"<p>Defining a mathematical object that can satisfy the functional properties of money is easier said than done. Martin Fowler's Money pattern<sup>[1]</sup> is a good starting place considering it is effectively the original source of the current de facto money implementation. The core concept of Fowler's Money pattern is that we have a class that encapsulates an amount and a currency together in one object that can be used in arithmetic operations. This is a simple idea that seems obvious in hindsight, but it was a foundational idea for application design, and most applications that do anything with money are at least partially inspired by it. The difficulty with Fowler's pattern and by consequence most, if not all, modern money frameworks, is that they treat money as a collection of separate pieces of data. An amount, a currency, an exchange rate, rounding rules, etc... This creates a fundamental problem when working with money in applications because the math that we can do with them is limited to the math that can be done with abstract numbers, but we need to do math with concrete numbers (e.g. 10 USD, 15 EUR, etc...). To support modern applications, we need some kind of mathematical model that can handle calculations with multiple different currencies at once without having to encode the concreteness of our monies in separate objects.</p> <p>Most modern currency frameworks improve upon Fowler's original single-class pattern, but they tend to focus on adding scaffolding around the original single-class pattern to handle other things like formatting and exchange. This has created some very useful frameworks that make life easier for the programmers that use them, but it ends up making the resulting framework more useful in a specific context without solving the general problem of working with monetary data programmatically, so not all applications benefit from or are able to use these frameworks. There is nothing in place to make the work of the framework authors easier, so improvements to existing frameworks and new, better frameworks are few and far between.</p> <p>The real issue we need to solve if we want a robust and language-agnostic pattern for working with money is not how to structure all of the separate pieces of data that can affect financial information, but how to actually do math with money instead of only numbers. If we can figure that out, then implementing any kind of currency framework will be much easier since we will have mathematically enforceable rules to guide our design decisions.</p> <p>The fundamental flaw in the current de facto standard money implementation is that it attempts to do math on integers or decimals instead of concrete monies, which causes the programmer (or pattern designer) to have to define their own rules of mathematics for working with money. Fowler actually points out this dilemma in his book when he discusses arithmetic between different currencies. He mentions that the simplest solution is to treat the addition/subtraction of two different currencies as an error, but it's also possible to use a structure like Ward Cunningham's Money Bag, an object that tracks values in multiple currencies simultaneously<sup>[1]</sup>, so this is a core issue of working with monetary data that Fowler was aware of over 20 years ago but the broader programming community has not paid much attention to, or at least has coped with instead of actively searching for a solution. Of note, Fowler doesn't advise how we should solve this particular problem in his book and instead, he leaves it as a sort of implementation detail for the programmer to decide based on the requirements of the application. This is understandable since the solution would be project-dependent when using this pattern, but this design decision the programmer has to make is deceptively problematic.</p> <p>It might not seem like it at first, but when we make these kinds of decisions, we are essentially redefining the rules of mathematics as they apply to money. This has very far-reaching consequences when we start doing more complicated things like integrating with third-party services or serializing monetary data since our calculations with money affect the accuracy of our data which has a very wide range of highly impactful uses.</p> <p>This isn't something that a developer should have to think about or decide. Even ignoring the additional design burden this places on the programmer, it also creates less reliable software. For example, what would happen if I decided that 2 + 2 = cheese, and then you tried to integrate a service I was providing with your application?</p> <p>At the end of the day, no matter how much we want to, programmers don't get to redefine the rules of the universe.</p> <p>Of course, we've been doing things this way for over 20 years, and it works, so why change it?</p> <p>Unfortunately, this isn't only an \"If it ain't broke, don't fix it.\" kind of issue. When it comes to programming, once we get into the realm of software, barring resource limitations, we can pretty much do whatever we want.</p> <p>Continuing with the example above, if I really did decide that I wanted 2 + 2 to equal cheese, I could do that:</p> <pre><code>class FourCheeseBlend(int):\n    \"\"\"An especially zesty integer.\"\"\"\n\n    def __add__(self, other) -&gt; int:\n        \"\"\"2 + 2 == cheese\"\"\"\n\n        if self == 2 and other == 2:\n            return hash(\"cheese\")\n        else:\n            return super().__add__(other)\n</code></pre> <p>The above Python class will integrate properly with any Python 3 program, it's type-safe, and the behavior will be correct until the program puts 2 and 2 together.</p> <p>However, once we need to calculate 2 + 2, the behavior of the program becomes undefined, and we have no indication that anything went wrong.</p> <p>The moral of this story is that just because we can make up our own rules doesn't mean that we should, and it would save us time and effort if we didn't have to.</p> <p>Of course, most reasonable programmers would think it's pretty obvious that the class above should never be used, but the reason why that is obvious is because the rules of basic arithmetic are obvious to us. However, when it comes to doing math with money, very few programmers (or anyone for that matter) actually understand the rules for how to calculate monetary amounts. In fact, at the time of writing, there don't seem to be any established mathematical rules for this, so I would argue that without mathematical truth to guide us, we have been including FourCheeseBlends in our financial applications for as long as we've been building them. We just haven't realized it yet.</p>"},{"location":"linear_money_model.html#developing-the-model","title":"Developing the Model","text":"<p>As mentioned in the previous section, to the best of my knowledge, there are no clearly defined mathematical properties of money in the current literature, so in order to define a mathematical model, we first need to identify those properties ourselves and decide on a purely mathematical object that is capable of encoding those properties for us.</p>"},{"location":"linear_money_model.html#conceptual-properties-of-money","title":"Conceptual Properties of Money","text":"<p>To start with, we should elaborate a bit on the three properties of money defined in the introduction:</p> <ol> <li>Unit of account:<ul> <li>Object is countable, usually in the form of uniform physical objects or fungible non-physical tokens of some kind.</li> </ul> </li> <li>Medium of exchange:<ul> <li>Object can be exchanged for (almost) any kind of physical or non-physical good or service at some predetermined price in units of the monetary object.</li> </ul> </li> <li>Store of value:<ul> <li>Object can still be used as a medium of exchange at any time in the foreseeable future.</li> </ul> </li> </ol> <p>In order to satisfy #1, we need to encode the fact that our money is a concrete number and do math with this concrete number without stripping away the unit that the number corresponds to.</p> <p>For #2, we have to satisfy #1 since we can't exchange an object or token for something else unless we can value the other object in terms of a certain number of countable units of our monetary object, but we also need to somehow show that a monetary object is convertible to other arbitrary objects at a specified rate in order to mathematically represent this property of money, so in order for our model to support #2, it needs to support conversion of currencies with foreign exchange rates between them or some other mathematical operation that corresponds to the exchange of a monetary object for some other object.</p> <p>For #3, we need to support #2 since the property of a store of value simply means that we can still use the object as a medium of exchange at some point in the future, but this is subtly difficult as it requires us to include some means of calculating the temporal nature of money in our model, otherwise we can't really prove that a medium of exchange used today is still a medium of exchange tomorrow.</p> <p>With this in mind, we need to ensure that our mathematical object has some way to ensure that these three properties are not lost when we perform calculations on monetary amounts, but we don't necessarily need to satisfy all three properties with a single mathematical object. We can use functions and higher level mathematical constructs in our model in order to satisfy all three properties for the model as a whole.</p>"},{"location":"linear_money_model.html#a-mathematical-money-object","title":"A Mathematical Money Object","text":"<p>Let's start by looking at the traditional money implementation first and see how well it satisfies our requirements.</p> <p>For #1, the standard implementation based on Fowler's pattern associates a single amount with a single currency inside an object to ensure we are always aware of the concreteness of the numbers we are working with, but this is an incomplete data model because a concrete number is still only a number mathematically, so using an object-oriented approach to encapsulating the amount and currency together in one object requires us to conceptually strip the currency away before and reattach it after any calculation we perform on the monetary amount, which is additional logical overhead for the class implementing the Money object and its maintainers. It would be best if we could somehow encode the fact that we are dealing with a concrete number in the mathematical object we use to represent monetary amounts numerically, so that these calculations would be handled seamlessly and the class can focus on tracking the high level data that matters to the user and abstracting away the mathematical implementation.</p> <p>For #2 and #3, the standard implementation offers no solution and Fowler's pattern doesn't make any suggestions for how to handle this. Essentially, the standard implementation only provides the properties of a unit of account, but does not satisfy the other requirements of money. This is why it is deceptively difficult to build applications to work with money. Even using an established pattern, we still have to deal with the other two properties of money on our own, which is where most of the functional behavior of money is actually determined since what really makes money different from any other countable object is its properties as a medium of exchange, so we really need a mathematical representation of money that encodes all of that for us, so we as programmers no longer have to build the scaffolding to support the other properties of money ourselves.</p> <p>Since we know that we can't have a store of value unless it is also a medium of exchange, and we can't have a medium of exchange unless it is also a unit of account, we can start by identifying a mathematical object capable of encoding and doing calculations with concrete numbers as that will ensure that our mathematical object represents something that is countable.</p>"},{"location":"linear_money_model.html#countable-monies","title":"Countable Monies","text":"<p>If we're looking for a mathematical object to represent a concrete number, we can find inspiration with mathematical representations of other units of measure. Just like Length, Width, and Height can be represented as a 3-dimensional vector in Euclidean space, we can represent a monetary amount of multiple currencies as an N-dimensional vector of concrete numbers. Each component of the vector will represent one of the N currencies we are working with in an N-dimensional vector space over the reals.</p> <p>For example, if we have 6 EUR and 10 USD in our wallet, we can represent the monetary value of our wallet as the vector \\((6,10)\\) assuming that we are only tracking EUR and USD in our application. If we were to add JPY to our application, we would have the vector \\((6,0,10)\\) assuming our vectors are represented in alphabetical order by currency.</p> <p>Of course, when working with vectors in practical applications, it's helpful to specify a basis. To keep things simple while we develop our model, we can simply use the standard Euclidean basis in N dimensions, so our basis vectors are all orthogonal to each other and of magnitude 1.</p> <p>We will follow a common convention and refer to this basis as \\(e\\) and its basis vectors via subscripts e.g. \\(e_1\\), \\(e_2\\), \\(e_n\\). The vector space spanned by the basis \\(e\\) will be referred to as \\(V\\).</p>"},{"location":"linear_money_model.html#doing-math-with-money","title":"Doing Math with Money","text":"<p>With the definitions in the previous section, we have the foundation for how to do math with multiple currencies simultaneously since we can encode the concreteness of our monetary values in the definition of the vector space and simply apply the rules of linear algebra to ensure the correctness of our monies without enforcing it in code.</p> <p>For example, if we have two money vectors in an \\((EUR, JPY, USD)\\) vector space:</p> <ul> <li>\\(u = (6, 500, 20)\\)</li> <li>\\(v = (0, 250, 10)\\)</li> </ul> <p>We can add and subtract like any other vector:</p> <ul> <li>\\(u + v = (6 + 0, 500 + 250, 20 + 10) = (6, 750, 30)\\)</li> <li>\\(u - v = (6 - 0, 500 - 250, 20 - 10) = (6, 250, 10)\\)</li> </ul> <p>It is plain to see that this form of arithmetic is consistent with what would happen if we performed these operations with cash in real life.</p> <p>Multiplication and division of vectors by scalars also makes sense when thinking in terms of cash:</p> <ul> <li>\\(2u = (6 \\cdot 2,\\ 500 \\cdot 2,\\ 20 \\cdot 2) = (12, 1000, 40)\\)</li> <li>\\(u \\div 2 = (6 \\div 2,\\ 500 \\div 2,\\ 20 \\div 2) = (3, 250, 10)\\)</li> </ul> <p>There isn't really any other way to interpret multiplication/division of our wallet other than doubling/halving the contents, so this makes sense for real-world applications.</p> <p>Of course, in most real-world situations, multiplication would only be done against a single currency, but it's good to have the rules for how to handle multiplication of multiple currencies established so that we don't have to decide them for ourselves.</p> <p>It's worth noting that these examples use cash to visualize the application of the model to real-world use cases, but the same concepts that apply to cash apply to digital currency as well. Even if there is no physical object, the same conceptual properties that make money what it is still apply. For example, we could define multiplication of two money vectors via the Hadamard product and the rules of linear algebra would keep our math consistent, but this would not reflect the reality of money. It doesn't make much sense to multiply an arbitrary object by another arbitrary object whether it is a physical object or a conceptual token. The properties of a unit of account as a quantity of some kind of object are universal whether the object is physical or not, so the intuition we develop through this model holds for money in general.</p> <p>We have a vector space, we can define physical assets as vectors, and we can use them in arithmetic, so we've mathematically satisfied the properties of a unit of account, but we need to be able to convert those physical assets to different currencies in order to satisfy the properties of a store of value and medium of exchange and finally get past the limitations we've faced for two decades, so how do we do that?</p>"},{"location":"linear_money_model.html#math-with-forex-rates","title":"Math with Forex Rates","text":"<p>In traditional applications we would use forex rates by multiplying our single-currency numerical amount by the rate to convert a currency from one to another, but for our purposes, we need to be able to convert all of the currencies in a money vector simultaneously, so it stands to reason that our forex rates need to be represented as a vector as well.</p> <p>Let's assume we have the following exchange rates in \\(V^3\\):</p> <ul> <li>EUR -&gt; EUR = 1.0</li> <li>JPY -&gt; EUR = 0.004</li> <li>USD -&gt; EUR = 0.4</li> </ul> <p>These rates correspond to the rates vector: \\(r = (1.0, 0.004, 0.4)\\), which represents the exchange rates from each of the currencies in \\(V\\) to EUR.</p> <p>Continuing with our asset vector from the previous sections \\(u = (6, 500, 20)\\), in order to convert this vector into a single specific currency, we need to somehow multiply all components of the vector by the exchange rate from that component's corresponding currency to the target currency and then sum the results in order to get the full value of the money vector in the target currency only.</p> <p>That sounds a lot like the dot product, doesn't it? Let's see what that looks like:</p> \\[ \\langle u,r \\rangle = (6 \\cdot 1.0 + 500 \\cdot 0.004 + 20 \\cdot 0.4) = (6 + 2 + 8) = 16 \\] <p>This works, but now our result is only an abstract number, so we've lost our ability to encode the fact that this is a concrete number that represents 16 EUR and not only 16.</p> <p>To solve that, we can multiply the result of the dot product calculation with the basis vector \\(e_k\\) that corresponds to the target currency since that vector is all 0s except for the target currency, which will be 1:</p> \\[ \\langle u,r \\rangle e_1 = 16 (1, 0, 0) = (16, 0, 0) = 16\\ EUR \\] <p>But what if we want to convert to JPY or any other currency, but we don't have a rates vector for that currency? That is to say, what if the only rates vector we have is the \\(r\\) vector representing the rates to EUR, but we want to convert to another currency in \\(V\\)?</p> <p>We can calculate the rates vector to convert to any other currency in \\(V\\) with a linear transformation of \\(r\\):</p> \\[ r'_k = \\frac{1}{\\langle r,e_k \\rangle}r \\] <p>The calculation above divides 1 by the scalar rate from our target currency to whatever currency \\(r\\) converts to, which in this case is EUR, in order to get the rate to our target currency from the target currency of \\(r\\). This result is then multiplied by the original \\(r\\) in order to convert all component rates to the rate from the component currency to the target currency.</p> <p>So, to convert our asset vector to JPY:</p> \\[ jpy = \\langle u,r'_2 \\rangle e_2 \\] <p>Or generally:</p> \\[ c_k = \\langle u,r'_k \\rangle e_k \\] <p>With this we can define a Convert function for converting any asset vector to any currency in \\(V\\):</p> \\[ C(v)_k = \\langle v,r'_k \\rangle e_k \\] <p>This works well, but \\(r'_k\\) is a bit too implicit in what it is actually doing. Essentially, the transformation \\(r'_k\\) is taking the vector \\(r\\) and transforming the rates to whatever currency corresponds to the index \\(k\\), but because these transformations are all related to each other, it would make the structure of this transformation clearer if we described it as a set of the vectors produced by transforming the rates represented by \\(r\\) to all of the different currencies in \\(V\\):</p> \\[ \\gamma = \\{ v_1,...,v_n\\ |\\ v_k = \\frac{1}{\\langle r,e_k \\rangle}r \\land 1 \\leq k \\leq n \\} \\] <p>For the remainder of this article, I will refer to the set resulting from the transformation above as the gamma set, and the vector representing the rates to currency \\(k\\) in the gamma set will be denoted \\(\\gamma_k\\).</p> <p>The set of vectors designated by \\(\\gamma\\) explicitly represents the exchange rates from each of the currencies in \\(V\\) to the currency corresponding to each index \\(k\\), so our \\(C\\) function remains the same, but we replace \\(r'_k\\) with \\(\\gamma_k\\), and the model is made clearer overall.</p> \\[ C(v)_k = \\langle v,\\gamma_k \\rangle e_k \\] <p>The nice thing about this transformation is that it gives the same result regardless of the choice of \\(r\\), so as long as we have all of the rates from each of the currencies in \\(V\\) to any arbitrary currency in \\(V\\), we can obtain the rates to any other arbitrary currency in \\(V\\) with the \\(C\\) function... sort of.</p> <p>There is a problem with our definition of \\(\\gamma\\) above. Since we don't place any kind of restriction on the value of \\(r\\), it acts on any arbitrary vector in \\(V\\), which means that we could provide an \\(r\\) that doesn't actually represent forex rates, which would contaminate our model. We need to somehow restrict the possible structure of \\(r\\) so that it can be guaranteed to actually represent a vector of forex rates.</p> <p>The first restriction we need to apply presents itself in the transformation originally given by \\(r'_k\\) and reused in the earlier definition of \\(\\gamma\\):</p> \\[ r'_k = \\frac{1}{\\langle r,e_k \\rangle}r \\] <p>This transformation includes a division of constant 1 by the result of the dot product. This means that the components of \\(r\\) can't be 0. If any of the components of \\(r\\) are 0, then at least one of the results of the \\(\\gamma\\) transformation will result in division by 0 when the dot product is taken with the basis vector of that index. If we were using the definition given by \\(r'_k\\), then we would only technically need to restrict the value of the component at index \\(k\\) to be non-zero since the \\(r'_k\\) transformation can be taken in isolation based on its definition, but with the set builder notation used for \\(\\gamma\\), all components of \\(r\\) must be non-zero since we apply this transformation to all components of \\(r\\) in order to obtain the gamma set:</p> \\[ \\{ r \\in V\\ |\\ (\\forall r_k) r_k \\not = 0 \\} \\] <p>This limitation is not simply a coincidence. Conceptually, forex rates represent the values of currencies in relation to each other, and this transformation has the effect of inverting this relationship for all of the currencies in \\(r\\). It doesn't make sense for any of the components of \\(r\\) to be 0 because, by the conceptual definition of money, a currency cannot have a value of 0. If it did, it would not be usable as a store of value or a medium of exchange. To illustrate this further, take a defunct currency that is no longer in circulation. It may have some value for collectors that would be willing to pay money to obtain it, but this exchange is in the form of the exchange of money for goods, not money for money, and you would not be able to use the defunct currency at the grocery store or to pay your rent, so it does not qualify as a general medium of exchange. If it can't be universally exchanged, then it can't store universal value into the future, so it is also not usable as a store of value. Any other situation that would result in an exchange rate of 0 will also represent an object that does not qualify as a general medium of exchange and thus does not qualify as a currency, so we can enforce a restriction that all components of \\(r\\) be non-zero, but to be more thorough, we should enforce that all values be positive since a negative value logically corresponds to debt, which is not a property of money itself and can be easily represented with negative quantities of money in our model.</p> \\[ \\{ r \\in V\\ |\\ (\\forall r_k) r_k &gt; 0 \\} \\] <p>The second restriction we need to apply to \\(r\\) is less obvious. At least one component of \\(r\\) must be exactly 1:</p> \\[ \\{ r \\in V\\ |\\ (\\exists r_k) r_k = 1 \\} \\] <p>The reason for this is better illustrated by example:</p> <p>let \\(r = (0.5, 0.004, 0.4)\\)</p> <p>If we calculate our gamma set with this \\(r\\), we get the following for \\(\\gamma_1\\): \\((1.0, 0.008, 0.8)\\)</p> <p>This is problematic because in order for our model to remain consistent, we need the equality: \\(\\gamma_k \\equiv r\\) to hold when \\(k\\) is the index of the currency that \\(r\\) represents the rates to. Otherwise, we can't trust that \\(\\gamma_k\\) represents the rates to the target currency. In the example above, this currency is EUR, and this equality does not hold. The reason is because \\(r\\) does not correctly represent the rates to any currency in \\(V\\). This is proven because our vectors always include all currencies in the space \\(V\\), and any vector that represents the rates to a currency in \\(V\\) will have a value of 1 for the component corresponding to the target currency since any currency has an exchange rate of 1 with itself. It's possible that multiple currencies could have a value of 1 since many currencies are pinned to the value of other currencies, but at least one component of the vector must be exactly 1 in order for the vector to be capable of correctly representing exchange rates in \\(V\\). A vector that does not include at least one component equal to 1 may technically be a set of forex rates, but only in a higher dimensional vector space. This could happen if we took a member of a vector subspace of \\(V^{n+x}\\) with dimension n as our \\(r\\) in \\(V^n\\), so we need to restrict the valid values of \\(r\\) explicitly.</p> <p>This gives us a definition for the set of all valid forex vectors in \\(V\\):</p> \\[ \\tau = \\{ r \\in V\\ |\\ \\forall r_k (r_k &gt; 0) \\land \\exists r_k (r_k = 1) \\} \\] <p>So, our final definition for the gamma set is:</p> \\[ \\gamma = \\{ v_1,...,v_n\\ |\\ v_k = \\frac{1}{\\langle r,e_k \\rangle}r \\land 1 \\leq k \\leq n \\land r \\in \\tau \\} \\] <p>With this, we have everything we need to do math with money... right?</p>"},{"location":"linear_money_model.html#exploring-currency-space","title":"Exploring Currency Space","text":"<p>We satisfied the properties of a medium of exchange, but there are some issues with the methods for conversion employed in the previous section.</p> <p>Particularly, this works well for a single point in time, but what if the exchange rates change? How do we track those changes? Recall that in order for our model to satisfy the properties of a store of value, we need to somehow encode the temporal characteristics of money as well.</p> <p>Fortunately, the concept of forex rates is inherently temporal since they change over time, so our model is capable of encoding the temporal properties of money simply by calculating a change in \\(\\gamma\\) within the same vector space. This is made trivial by the fact that \\(\\gamma\\) defines a set of vectors in \\(V\\), so all we have to do to track the temporal changes in money is track the movement of the vectors contained in the gamma set. For example:</p> <ul> <li>Let \\(\\gamma'\\) be the new forex rates, then</li> </ul> \\[ \\Delta = \\{ v_1,...,v_n | v_k = \\gamma'_k - \\gamma_k \\} \\] <p>This also aligns well with the way that we deal with forex rates in real life since forex rates are constantly fluctuating, but we actually use snapshots of them at various points in time, so by representing them as vectors we are able to mathematically model movement of forex rates over time in the same way that we can model movement of objects in 3D space through vector transformations.</p> <p>It's helpful to think of the vector space \\(V\\) as a Currency Space, and the gamma set as a set of linear transformations of the Currency Space. This terminology is useful because it describes the actual mathematical behavior of money. Within \\(V\\), we can represent monetary values of the currencies in \\(V\\) as arbitrary vectors, and we can track the fluctuations of the values of those currencies over time via \\(\\gamma\\).</p> <p>In this way, we can model the movement of monetary values over time, which provides us with the final piece needed to satisfy the properties of a store of value mathematically. This model is technically sufficient for representing money mathematically, but we can still improve the practical usability of it.</p>"},{"location":"linear_money_model.html#evaluation","title":"Evaluation","text":"<p>The model we have defined so far technically satisfies the functional properties of money, but there is another conceptual operation that we can add to our model to simplify its use in practical applications that require lots of currency conversions.</p> <p>Most of the situations that require currency conversion in financial applications actually only need to evaluate the monetary amount in some target currency, but they do not actually represent a transaction where currencies are exchanged. For example, when purchasing goods in an international web store, the items may be valued in the local currency of the retailer, but the cart may display the cost of the total purchase in the user's local currency. There is no actual transaction associated with the display of the total price in the website's UI, the actual conversion would occur when the user makes the purchase and their local currency is converted to the transaction currency for payment, but with a traditional model, we would convert the currency to the user's local currency and then display a formatted amount to the user before any actual transaction takes place.</p> <p>If we separate the concepts of conversion and evaluation we can make it easier to work with money programmatically by allowing the reduction of a monetary amount to an abstract number representing its value in a specific currency. Similar to how the dot product taking two vectors and producing a scalar allows more complex vector operations to be defined on a vector space, this opens up additional possibilities for how to apply the model in our applications without losing any of the provability that the model is intended to provide.</p> <p>The Convert and Evaluate operations can be summarized informally as follows:</p> <ul> <li>Convert:<ul> <li>Represents the transactional exchange of one currency for another.</li> <li>Generally, anything that would be recorded as a transaction in a bookkeeping sense.</li> <li>E.g. Trading on the forex market, exchanging cash at a customs office, making a purchase in a foreign currency (your money is converted to the transaction currency at the time of the transaction).</li> </ul> </li> <li>Evaluate:<ul> <li>Represents the valuation of an amount of one currency in another currency but not an actual exchange of the currencies.</li> <li>Pretty much anything that isn't an actual transaction would be an evaluation.</li> <li>Most traditional uses of currency conversion in applications fall into this category.</li> <li>E.g. Displaying an amount in the user's local currency. Doing a preliminary calculation before a transaction, \"how much is this in xyz?\".</li> </ul> </li> </ul> <p>Given the above description, how do we represent the Evaluate operation mathematically?</p> <p>Evaluation essentially boils down to checking the value of a conversion before committing to the full transaction, and if we recall our definition of the convert function:</p> \\[ C(v)_k = \\langle v,\\gamma_k \\rangle e_k \\] <p>We noticed while we were developing that portion of the model that the intermediate calculation \\(\\langle v,r \\rangle\\) gives an abstract number, which was problematic for our convert function, so we multiplied it by the basis vector \\(e_k\\) to get an asset vector representing the collapsed monetary amount, but as described above, for the evaluation of a monetary amount, we actually want an abstract number since we don't want to construct a new vector representing some physical currency. We actually want to escape the vector space entirely, so our evaluate function is simply the intermediate stage of the convert function:</p> \\[ E(v)_k = \\langle v,\\gamma_k \\rangle \\] <p>And we can redefine our \\(C\\) function to use this as well:</p> \\[ C(v)_k = E(v)_k e_k \\] <p>With these two functions and our definitions of \\(\\tau\\) and \\(\\gamma\\), we have everything we need for our complete mathematical model of money and a little bit extra.</p>"},{"location":"linear_money_model.html#putting-it-all-together","title":"Putting it all together","text":"<p>Here is the full model in its entirety:</p> <ul> <li>Assumptions:<ul> <li>Let \\(V\\) be the n-dimensional Euclidean vector space over \\(\\mathbb{R}\\)</li> <li>Let \\(e\\) be the standard basis in \\(V\\)</li> </ul> </li> </ul> \\[ \\tau = \\{ r \\in V\\ |\\ \\forall r_k (r_k &gt; 0) \\land \\exists r_k (r_k = 1) \\} \\] \\[ \\gamma = \\{ v_1,...,v_n\\ |\\ v_k = \\frac{1}{\\langle r,e_k \\rangle}r \\land 1 \\leq k \\leq n \\land r \\in \\tau \\} \\] \\[ E(v)_k = \\langle v,\\gamma_k \\rangle \\] \\[ C(v)_k = E(v)_k e_k \\]"},{"location":"linear_money_model.html#notes-on-performance","title":"Notes on Performance","text":"<p>Most programmers would have noticed that, with this model, monetary calculations are in linear time. At first glance, it definitely seems like this would make calculations much slower than a traditional model, but this is not necessarily true.</p> <p>I won't make any assertions about the specific performance of the linear model compared to the traditional model since I have not profiled them against each other, and there are too many factors that contribute to performance to draw a meaningful conclusion about the difference, but I want to clarify that the time complexity of the linear model is not usually linear in practice.</p> <p>Generally speaking, calculations in the linear model would run in O(n) time, where n is the dimension of our currency space, but because most practical applications will not change the currency space at run-time, we can consider the running time to be constant.</p> <p>For example, if you have an application that supports EUR, JPY, and USD as in our previous examples, then the running time for calculations would be O(3) since n is constant at run-time. This is not simply a pedantic difference because the running time of calculations between two vectors really does remain constant with respect to input. Of course, the constant multiplier of 3 means that even if we add two vectors that only have one component with a value, such as two vectors of only USD where EUR and JPY are both 0, then the running time will still be O(3) even though only one value of each of the vectors is actually relevant to the calculation. From this, we see that in some situations the traditional model will be more efficient, but in practice, if the application does need to do calculations with multiple currencies, then the running time of the traditional model will still be O(n), where n is the number of currencies involved. Additionally, in the traditional model, each of those n calculations are between user-defined types, but in the linear model, each of the n calculations are between primitive numeric types, so the constant factor of each individual calculation should be lower in both CPU time and memory usage in the linear model.</p> <p>As a rule of thumb, performance will degrade in the linear money model compared to the traditional model as the difference between the number of components of the vector that have a value and the dimension of the currency space grows. E.g. a vector with only one value in a 20-dimension currency space will likely perform worse than a traditional money type, but a calculation with 20 currencies will likely be faster and use less memory in the linear model with a 20-dimensional currency space than in the traditional model. Also, most practical applications only support a small number of currencies, and most time complexity issues only come into play at fairly large inputs, so it's likely that the usage of primitive types will make the linear model more efficient in most practical applications regardless of the number of valued components in the calculation.</p> <p>Again, this is based on the time complexity and general assumptions about the performance of primitive types vs user-defined types. Depending on the language and implementations, either model could outperform the other. Always profile your code.</p> <p>Lastly, when I say most practical applications, I'm referring to applications that have complete control over the monetary calculations they perform. Common examples include accounting software, point-of-sale systems, and ERP software. However, this does not apply to many developer tools or resources that provide services related to arbitrary currencies such as a currency library implementing the linear money model. In that kind of application, the time complexity would be linear due to the unknown dimension of the currency space for the end-user. In other words, if you define the currency space of the application explicitly, the running time is constant and can be accounted for, but if you let the user define the currency space or it is dynamically sized, then the time complexity is linear. This should be kept in mind when creating services/libraries that will be consumed by other applications.</p>"},{"location":"linear_money_model.html#conclusion","title":"Conclusion","text":"<p>With the model developed in this article, we have a mathematical representation of the functional properties of money and a clear definition of how arithmetic with monetary values should work due to the mathematical rules of linear algebra:</p> <ul> <li>Addition and Subtraction of monies and other monies is allowed.</li> <li>Addition and Subtraction of monies and scalars is not allowed.</li> <li>Multiplication and Division of monies by scalars is allowed.</li> <li>Multiplication and Division of monies by other monies is not allowed.</li> </ul> <p>Additionally, because of the rules of linear algebra, we can easily use monetary values in calculations in other schools of math that have rules for interpreting vectors such as calculus and exterior algebra. This is likely useful for Economics where linear algebra and calculus are already used frequently, but it could also prove useful for developing complex models through dimensional analysis since it provides a clear definition of the mathematical structure of monetary values as units of currencies.</p> <p>I hope that this article has provided some insight into the mathematical properties of money and how we can leverage these properties to create more robust financial applications.</p>"},{"location":"linear_money_model.html#references","title":"References","text":"<p>[1] M. Fowler, Patterns of Enterprise Application Architecture Addison-Wesley Professional. 2002 ISBN-10: 0-321-12742-0 ISBN-13: 978-0-321-12742-6</p>"},{"location":"quickstart.html","title":"Quickstart Tutorial","text":"<p>In this quick start guide, we'll make a simple commandline currency converter. Knowledge of commandline application development is not required to complete  this tutorial. However, a basic understanding of Python and running Python  scripts is assumed. It should take about 30 minutes to complete.</p> <p>By the end of this tutorial, you should know how to:</p> <ul> <li>Parse and utilize foreign exchange rates, localization, and rounding data for currency conversions and formatting.</li> <li>Create money vectors and use them in calculations.</li> <li>Display money to a user in a localized format.</li> </ul> <p>Let's get started!</p>"},{"location":"quickstart.html#installation","title":"Installation","text":"<p>This tutorial does not use any dependencies outside the standard library other than <code>linearmoney</code>.</p> <pre><code>pip install linearmoney\n</code></pre>"},{"location":"quickstart.html#boilerplate","title":"Boilerplate","text":"<p>Add (or just copy and paste) the following code to a new file called <code>converter.py</code>:</p> <pre><code>#!/usr/bin/python\n\n\"\"\"Interactive commandline script for converting currencies.\n\nConverts &lt;amount&gt; of &lt;from_currency&gt; to &lt;to_currency&gt;\n\nUsage: [-h|--help] &lt;amount&gt; &lt;from_currency&gt; &lt;to_currency&gt;\n\"\"\"\n\nif __name__ != \"__main__\":\n    raise ImportError(\"This is a standalone script and should not be imported.\")\n\nwhile True:\n    readline = input(\"Currency Converter--&gt; \")\n</code></pre> <p>Since we intend for this to be an interactive commandline app, we don't want the code to execute when imported, so we raise an <code>ImportError</code> immediately if it is not running directly from the commandline.</p> <p>The infinite loop at the end creates our interactive command prompt with the builtin <code>input</code> function. If you've never built a commandline app before, this infinite loop might have you concerned, but this is a very simple way to emulate a custom command prompt. We're using the <code>input</code> builtin to provide a prompt and store whatever string that the user inputs on the commandline into the <code>readline</code> variable. We aren't doing anything with this user input yet, but this is the basic structure of our application. Ctrl+C can be used to exit the infinite loop.</p> <p>The docstring outlines what we expect the app to do. We pass in a numeric amount, a currency to convert from, and a currency to convert to, and it converts the value for us, so let's implement that.</p>"},{"location":"quickstart.html#converting-currencies","title":"Converting Currencies","text":"<p>First off, we'll add <code>linearmoney</code> to our imports at the top of the file:</p> <pre><code>...\n\nif __name__ != \"__main__\":\n    raise ImportError(\"This is a standalone script and should not be imported.\")\n\nimport linearmoney as lm\n\nwhile True:\n    readline = input(\"Currency Converter--&gt; \")\n</code></pre> <p>Next, if we are going to convert currencies, we'll need exchange rates. linearmoney provides a helpful <code>forex</code> function for coercing a dictionary of exchange rates into a vector that can be used by the conversion functions, but we still need to get rates from somewhere.</p> <p>In this case, I'm using the awesome https://theforexapi.com, which is a free public web API for forex rates:</p> <pre><code>import time\nimport urllib.request\nimport json\n\nimport linearmoney as lm\n\ndef request_rates() -&gt; dict:\n    \"\"\"Request the latest rates from theforexapi.com and\n    return them as a dict.\"\"\"\n\n    print(\"Fetching latest forex rates from theforexapi.com...\")\n    print(\"Waiting 2 seconds to comply with api rate limits...\")\n    time.sleep(2)  # Respect API rate limits.\n    url = \"https://theforexapi.com/api/latest\"\n    with urllib.request.urlopen(url) as response:\n        rate_dict = json.loads(response.read().decode(\"utf-8\"))\n        return rate_dict\n</code></pre> <p>If you haven't made HTTP requests with Python before, don't worry about understanding this code. The <code>request_rates</code> function just uses the standard library's <code>urllib.request</code> to fetch the latest exchange rates from theforexapi and returns them as a Python dictionary.</p> <p>We also wait two seconds before making the request to avoid violating the APIs soft rate limits due to a programming oversight such as accidentally calling this function in a loop.</p> <p>This dictionary is of a particular structure that is common among web APIs for forex rates. It includes a <code>base</code> key that indicates the base currency of each exchange rate pair, and then a <code>rates</code> key, which is another nested Dictionary where each key is the quote currency, and the value is the rate from the base currency to the quote currency.</p> <p>The <code>forex</code> function accepts this structure of Dictionary directly, so we can simply pass the result of the <code>request_rates</code> function into the <code>forex</code> function to get a <code>ForexVector</code> that we can use to convert currencies in our script:</p> <pre><code>forex_vector = lm.vector.forex(request_rates())\ncurrency_space = lm.vector.space(forex_vector)\n</code></pre> <p><code>ForexVectors</code> represent a specific set of exchange rates in a structure understood internally by linearmoney and are not intended to be used in calculations directly.</p> <p>The <code>currency_space</code> is another key part of the linearmoney math model. In mathematical terms, it defines the vector space of all monetary calculations, but in practical terms, it's basically a strict definition of the allowed currencies for a calculation. We will see how this is used and enforced later on, but for now we just need to know that it is using the forex rates we fetched from <code>theforexapi</code> to determine which currencies we can calculate/convert.</p>"},{"location":"quickstart.html#commandline-arguments","title":"Commandline Arguments","text":"<p>Just like a single-run commandline script, we'll treat user input as a set of arguments, so we need to process the string that the user provides in our while loop.</p> <p>Since our script is supposed to convert an amount of one currency to another, we need three arguments:</p> <ol> <li>The numeric amount to convert.</li> <li>The currency code of the currency we are converting from.</li> <li>The currency code of the currency we are converting to.</li> </ol> <pre><code>while True:\n    readline = input(\"Currency Converter--&gt; \")\n    raw_args = readline.split()  # [&lt;amount&gt;, &lt;from_currency&gt;, &lt;to_currency&gt;]\n    print(f\"amount: {raw_args[0]}\")\n    print(f\"from_currency: {raw_args[1]}\")\n    print(f\"to_currency: {raw_args[2]}\")\n</code></pre> <p>This is the most basic way to parse the arguments for our currency converter. Now let's use them to actually convert the amount:</p> <pre><code>while True:\n    readline = input(\"Currency Converter--&gt; \")\n    raw_args = readline.split()  # [&lt;amount&gt;, &lt;from_currency&gt;, &lt;to_currency&gt;]\n    asset_vector = lm.vector.asset(raw_args[0], raw_args[1], currency_space)\n    converted_value = lm.vector.evaluate(\n        asset_vector, raw_args[2], forex_vector\n    )\n    to_currency = lm.data.currency(raw_args[2])\n    rounded_value = lm.scalar.roundas(converted_value, to_currency)\n    result = lm.scalar.l10n(rounded_value, to_currency, lm.data.system_locale())\n    print(result)\n</code></pre> <p>Let's break down the above code.</p> <pre><code>    asset_vector = lm.vector.asset(raw_args[0], raw_args[1], currency_space)\n</code></pre> <p>The <code>asset_vector</code> uses the <code>asset</code> function to create a new vector representing the monetary amount of the <code>amount</code> argument in the currency <code>&lt;from_currency&gt;</code>.</p> <p>Notice the use of the <code>currency_space</code> that we defined earlier. The <code>asset</code> function requires us to provide a currency space when creating a vector in order to ensure that any calculations with other vectors are in the same currency space. For example, if we create another asset using a different currency space and then we try to add the two different assets together, we will get a <code>SpaceError</code>, and the same would happen if we tried to evaluate the asset vector we created using a forex vector that was in a different currency space. Since we created our <code>currency_space</code> from our <code>forex_vector</code>, we can ensure that any math required to evaluate the asset we create will work correctly by creating the asset in the same currency space.</p> <pre><code>    converted_value = lm.vector.evaluate(\n        asset_vector, raw_args[2], forex_vector\n    )\n</code></pre> <p>The call to <code>evaluate</code> converts the total value of the asset vector to the currency defined by <code>&lt;to_currency&gt;</code> using the exchange rates in <code>forex_vector</code>. This function returns a <code>decimal.Decimal</code>, not another asset vector. For the remainder of this tutorial, we will refer to this as evaluation, not conversion. See also Evaluation and Conversion.</p> <p>In this case, our asset vector was just created and only has one component in one currency, so it doesn't really matter, but the <code>evaluate</code> function will give the total value of the entire asset in the target currency even if our asset vector contained values in multiple currencies, so this allows us to program more complex applications in a way where we don't have to worry about what currency a monetary amount is in, we just call <code>evaluate</code> to get the value in the currency we want at that point in time, and it Just Works \u2122. The same goes for converting assets with <code>convert</code>.</p> <pre><code>    to_currency = lm.data.currency(raw_args[2])\n    rounded_value = lm.scalar.roundas(converted_value, to_currency)\n    result = lm.scalar.l10n(rounded_value, to_currency, lm.data.system_locale())\n    print(result)\n</code></pre> <p>The <code>l10n</code> function formats a decimal using the local currency representation for the provided locale. The <code>roundas</code> function rounds a decimal value based on the provided currency data. We round before localizing to ensure that the string returned by the <code>l10n</code> function is correctly formatted with the rounded value. Both the locale and the currency are Datasources, and we have to construct them using the corresponding factory functions.</p> <p>The <code>currency</code> function takes an ISO 4217 currency code (e.g. \"USD\") and returns the rounding data for the corresponding currency, so we call it with the <code>&lt;to_currency&gt;</code> in order to get the correct rounding data for our <code>converted_amount</code> before formatting with the current system locale.</p> <p>The <code>system_locale</code> function provides the locale data for the POSIX locale of the running Python process.</p> <p>linearmoney provides a threadsafe <code>locale</code> function that returns the locale data for the provided language-region combination, and it allows overriding the individual properties of the returned data, so it can be used to create custom currency formats and is very useful in modern distributed systems and web applications where the executing environment is often not in the same locale as the user of the application, but in the case of a local application such as our currency converter script, we usually want to just use the locale of the running system without needing to provide any configuration or other data to determine the correct locale. linearmoney provides the <code>system_locale</code> helper function for this exact use-case, so instead of writing code to read the system locale with the stdlib or through some other means and then passing that into the <code>locale</code> function to get a <code>LocaleData</code> instance usable by the library, we just call <code>system_locale</code>, and we're good to go.</p> <p>At this point, we should have the following script:</p> <pre><code>#!/usr/bin/python\n\n\"\"\"Interactive commandline script for converting currencies.\n\nConverts &lt;amount&gt; of &lt;from_currency&gt; to &lt;to_currency&gt;\n\nUsage: [-h|--help] &lt;amount&gt; &lt;from_currency&gt; &lt;to_currency&gt;\n\"\"\"\n\nif __name__ != \"__main__\":\n    raise ImportError(\"This is a standalone script and should not be imported.\")\n\nimport time\nimport urllib.request\nimport json\n\nimport linearmoney as lm\n\n\ndef request_rates() -&gt; dict:\n    \"\"\"Request the latest rates from theforexapi.com and\n    return them as a dict.\"\"\"\n\n    print(\"Fetching latest forex rates from theforexapi.com...\")\n    print(\"Waiting 2 seconds to comply with api rate limits...\")\n    time.sleep(2)  # Respect API rate limits.\n    url = \"https://theforexapi.com/api/latest\"\n    with urllib.request.urlopen(url) as response:\n        rate_dict = json.loads(response.read().decode(\"utf-8\"))\n        return rate_dict\n\n\nforex_vector = lm.vector.forex(request_rates())\ncurrency_space = lm.vector.space(forex_vector)\n\nwhile True:\n    readline = input(\"Currency Converter--&gt; \")\n    raw_args = readline.split()  # [&lt;amount&gt;, &lt;from_currency&gt;, &lt;to_currency&gt;]\n    asset_vector = lm.vector.asset(raw_args[0], raw_args[1], currency_space)\n    converted_value = lm.vector.evaluate(\n        asset_vector, raw_args[2], forex_vector\n    )\n    to_currency = lm.data.currency(raw_args[2])\n    rounded_value = lm.scalar.roundas(converted_value, to_currency)\n    result = lm.scalar.l10n(rounded_value, to_currency, lm.data.system_locale())\n    print(result)\n</code></pre> <p>If we run this with <code>python converter.py</code>, then we should see a couple of print statements about fetching forex rates and then the prompt <code>Currency Converter--&gt;</code> should come up.</p> <p>If we enter something like <code>10 usd jpy</code> into this prompt and press enter, then we should see the converted and formatted amount printed out.</p> <p>Assuming the above is working correctly, we now have a working commandline currency converter, but there is a problem; we have no error handling. If we enter something like: <code>\"bad argument values\"</code>, then our app crashes with a weird exception about <code>ARGUMENT</code> not being a part of currency space.</p> <p>Since this is a REPL-like commandline app, we don't want it to crash when we get an exception, and ideally, we would also have some helpful feedback if the user provides invalid input.</p> <p>Enter the standard library's <code>argparse</code> module.</p>"},{"location":"quickstart.html#argparse","title":"Argparse","text":"<p>Python's <code>argparse</code> module can be overwhelming if you've never used it before, so you don't need to understand all of the code in this section. All of the relevant objects and methods will be explained.</p> <p>To start with, we'll import the <code>argparse</code> module and create an <code>ArgumentParser</code>:</p> <pre><code>if __name__ != \"__main__\":\n\n    raise ImportError(\"This is a standalone script and should not be imported.\")\n\nimport argparse\nimport time\nimport urllib.request\nimport json\n\nimport linearmoney as lm\n\nforex_vector = lm.vector.forex(request_rates())\ncurrency_space = lm.vector.space(forex_vector)\n\nparser = argparse.ArgumentParser(\n    prog=\"Currency Converter--&gt;\",\n    description=\"Convert &lt;amount&gt; of &lt;from_currency&gt; to &lt;to_currency&gt;\",\n    epilog=\"Use ctrl+c to exit/quit.\",\n)\n</code></pre> <p>The <code>ArgumentParser</code> instance will be used to read the user input and validate it as arguments while providing a standard help/man page for our commandline app.</p> <p>The <code>prog</code> argument is what will be displayed in the help/man page as the invocation for the usage examples. We set it to the text of our custom prompt to make the examples in the generated help match the interactive prompt.</p> <p>The <code>description</code> is like the first line of a Python docstring and gives a basic summary of the app.</p> <p>The <code>epilog</code> is an optional string that will be displayed after the rest of the generated help/man page. Since we don't have an explicit exit command that will be documented, we give an explanation of how to exit the application here.</p>"},{"location":"quickstart.html#parsing-args","title":"Parsing Args","text":"<p>Now that we have an <code>ArgumentParser</code> instance, we can define our three arguments:</p> <pre><code>parser = argparse.ArgumentParser(\n    prog=\"Currency Converter--&gt;\",\n    description=\"Convert &lt;amount&gt; of &lt;from_currency&gt; to &lt;to_currency&gt;\",\n    epilog=\"Use ctrl+c to exit/quit.\",\n)\n\nparser.add_argument(\n    \"amount\",\n    metavar=\"&lt;amount&gt;\",\n    help=\"\"\"The monetary value to convert from one currency to another.\n    Must be convertable to Python's decimal.Decimal type. E.g. 100, 100.0,\n    1E+2, etc...\"\"\",\n)\n\nparser.add_argument(\n    \"from_currency\",\n    metavar=\"&lt;from_currency&gt;\",\n    help=f\"\"\"The case-insensitive ISO 4217 aplphabetic currency code\n    of the &lt;amount&gt;. Accepted values: {currency_space.currencies}.\"\"\",\n)\n\nparser.add_argument(\n    \"to_currency\",\n    metavar=\"&lt;to_currency&gt;\",\n    help=f\"\"\"The case-insensitive ISO 4217 alphabetic currency code\n    to convert the &lt;amount&gt; to. Accepted values: {currency_space.currencies}.\"\"\",\n)\n</code></pre> <p>The <code>ArgumentParser.add_argument</code> method adds the metadata for an argument with optional help text to the parser.</p> <p>The <code>metavar</code> is how the argument will be displayed in usage examples in the generated help/man page.</p> <p>With the metadata for our commandline arguments added to the parser, we can now update our while loop to use the parser instead of a simple list for our arguments:</p> <pre><code>while True:\n    readline = input(\"Currency Converter--&gt; \")\n    raw_args = readline.split()\n    try:\n        args = parser.parse_args(raw_args)\n    except SystemExit:\n        # We want to show the error, but not kill the interactive prompt.\n        pass\n    else:\n        asset_vector = lm.vector.asset(args.amount, args.from_currency, currency_space)\n        converted_value = lm.vector.evaluate(\n            asset_vector, args.to_currency, forex_vector\n        )\n        to_currency = lm.data.currency(args.to_currency)\n        rounded_value = lm.scalar.roundas(converted_value, to_currency)\n        result = lm.scalar.l10n(rounded_value, to_currency, lm.data.system_locale())\n        print(result)\n</code></pre> <p>The <code>ArgumentParser.parse_args</code> method normally parses the arguments passed to the script on the commandline, but since we are parsing args in a loop, we can pass in the list of strings from the user input directly to the <code>parse_args</code> method, and it will parse them as if they were passed directly to the script.</p> <p>The standard behavior of a commandline app is to send an interrupt when something goes wrong, which will cause the script to exit and dump some kind of output, but we are running an interactive prompt, so we don't want our script to exit when it runs into an error, so we catch the <code>SystemExit</code> exception, which should be thrown by the <code>ArgumentParser</code> when it wants to indicate an exit interrupt should be sent.</p> <p>The members of <code>args</code> are the named arguments we defined with each call to <code>add_argument</code> previously, so we can access them by name.</p> <p>At this point, our <code>converter.py</code> should look like this:</p> <pre><code>#!/usr/bin/python\n\n\"\"\"Interactive commandline script for converting currencies.\n\nConverts &lt;amount&gt; of &lt;from_currency&gt; to &lt;to_currency&gt;\n\nUsage: [-h|--help] &lt;amount&gt; &lt;from_currency&gt; &lt;to_currency&gt;\n\"\"\"\n\nif __name__ != \"__main__\":\n    raise ImportError(\"This is a standalone script and should not be imported.\")\n\nimport argparse\nimport time\nimport urllib.request\nimport json\n\nimport linearmoney as lm\n\n\ndef request_rates() -&gt; dict:\n    \"\"\"Request the latest rates from theforexapi.com and\n    return them as a dict.\"\"\"\n\n    print(\"Fetching latest forex rates from theforexapi.com...\")\n    print(\"Waiting 2 seconds to comply with api rate limits...\")\n    time.sleep(2)  # Respect API rate limits.\n    url = \"https://theforexapi.com/api/latest\"\n    with urllib.request.urlopen(url) as response:\n        rate_dict = json.loads(response.read().decode(\"utf-8\"))\n        return rate_dict\n\n\nforex_vector = lm.vector.forex(request_rates())\ncurrency_space = lm.vector.space(forex_vector)\n\nparser = argparse.ArgumentParser(\n    prog=\"Currency Converter--&gt;\",\n    description=\"Convert &lt;amount&gt; of &lt;from_currency&gt; to &lt;to_currency&gt;\",\n    epilog=\"Use ctrl+c to exit/quit.\",\n)\n\nparser.add_argument(\n    \"amount\",\n    metavar=\"&lt;amount&gt;\",\n    help=\"\"\"The monetary value to convert from one currency to another.\n    Must be convertable to Python's decimal.Decimal type. E.g. 100, 100.0,\n    1E+2, etc...\"\"\",\n)\n\nparser.add_argument(\n    \"from_currency\",\n    metavar=\"&lt;from_currency&gt;\",\n    help=f\"\"\"The case-insensitive ISO 4217 aplphabetic currency code\n    of the &lt;amount&gt;. Accepted values: {currency_space.currencies}.\"\"\",\n)\n\nparser.add_argument(\n    \"to_currency\",\n    metavar=\"&lt;to_currency&gt;\",\n    help=f\"\"\"The case-insensitive ISO 4217 alphabetic currency code\n    to convert the &lt;amount&gt; to. Accepted values: {currency_space.currencies}.\"\"\",\n)\nwhile True:\n    readline = input(\"Currency Converter--&gt; \")\n    raw_args = readline.split()\n    try:\n        args = parser.parse_args(raw_args)\n    except SystemExit:\n        # We want to show the error, but not kill the interactive prompt.\n        pass\n    else:\n        asset_vector = lm.vector.asset(args.amount, args.from_currency, currency_space)\n        converted_value = lm.vector.evaluate(\n            asset_vector, args.to_currency, forex_vector\n        )\n        to_currency = lm.data.currency(args.to_currency)\n        rounded_value = lm.scalar.roundas(converted_value, to_currency)\n        result = lm.scalar.l10n(rounded_value, to_currency, lm.data.system_locale())\n        print(result)\n</code></pre> <p>If we try running it as is, we can access the generated help/man page with the <code>-h</code> option flag, and we see that our app does not exit, even though the generated help says \"show this help message and exit\".</p> <p>The <code>-h</code> option flag prints the generated help text and sends the <code>SystemExit</code> exception, so our generated help doesn't quite match the behavior of our interactive prompt, but changing this is outside the scope of this tutorial, so we'll just ignore that minor inconsistency.</p> <p>Unfortunately, we still haven't provided any error handling, and if we give our script our <code>\"bad argument values\"</code>, it still crashes just like before.</p> <p>Let's fix that.</p>"},{"location":"quickstart.html#error-handling","title":"Error handling","text":"<p>The <code>add_argument</code> method can take an optional <code>type</code> argument that is used when parsing arguments to coerce the type of the argument from the <code>str</code> that is provided on the commandline to the appropriate runtime type. The value of the <code>type</code> argument should therefore be a callable that takes in a string and returns a value of the desired type.</p> <p>Let's start with the <code>&lt;amount&gt;</code> argument:</p> <pre><code># imports\nimport decimal\n\nparser.add_argument(\n    \"amount\",\n    metavar=\"&lt;amount&gt;\",\n    type=decimal.Decimal,\n    help=\"\"\"The monetary value to convert from one currency to another.\n    Must be convertable to Python's decimal.Decimal type. E.g. 100, 100.0,\n    1E+2, etc...\"\"\",\n)\n</code></pre> <p>We set the <code>type</code> to <code>decimal.Decimal</code> since that is a valid type for our <code>asset</code> function's <code>amount</code> argument that does not lose any information. E.g. we don't want to use something like <code>int</code> as that would destroy any sub-currency amounts we provide.</p> <p>If we make this change and then pass in our <code>\"bad argument values\"</code>, we'll see that the error has changed to <code>decimal.InvalidOperation</code>. This is because instead of simply exposing the value as-is in <code>args</code>, the <code>ArgumentParser.parse_args</code> method first calls the <code>decimal.Decimal</code> constructor with the value of the <code>&lt;amount&gt;</code> argument, which results in an exception since <code>\"bad\"</code> can't be converted to a decimal.</p> <p>What we want is to turn this exception into a <code>SystemExit</code> if we can't convert the <code>&lt;amount&gt;</code> to a decimal, but we also want some kind of feedback to be printed out so that the user knows that they provided an invalid value, so let's write a function that we can provide as the <code>type</code> argument for <code>&lt;amount&gt;</code>:</p> <pre><code>def _error_decimal(amount: str) -&gt; decimal.Decimal:\n    \"\"\"Wrapper function that validates input as a decimal-compatible value.\"\"\"\n\n    try:\n        return decimal.Decimal(amount)\n    except decimal.InvalidOperation:\n        raise argparse.ArgumentTypeError(f\"Invalid numeric string '{amount}'\")\n\n\nparser = argparse.ArgumentParser(\n    prog=\"Currency Converter--&gt;\",\n    description=\"Convert &lt;amount&gt; of &lt;from_currency&gt; to &lt;to_currency&gt;\",\n    epilog=\"Use ctrl+c to exit/quit.\",\n)\n\nparser.add_argument(\n    \"amount\",\n    metavar=\"&lt;amount&gt;\",\n    type=_error_decimal,\n    help=\"\"\"The monetary value to convert from one currency to another.\n    Must be convertable to Python's decimal.Decimal type. E.g. 100, 100.0,\n    1E+2, etc...\"\"\",\n)\n</code></pre> <p>The <code>_error_decimal</code> function raises <code>argparse.ArgumentTypeError</code>, which will result in the <code>parse_args</code> method printing the error message we provide to the exception before raising a <code>SystemExit</code> exception, so we will get both proper error feedback to the user, and we will not break our interactive prompt with an uncaught exception.</p> <p>This takes care of the first argument, but what about the other two?</p> <p>The <code>&lt;from_currency&gt;</code> and <code>&lt;to_currency&gt;</code> arguments are actually strings, but they need to be valid currency codes in our <code>currency_space</code>. Fortunately for us, the <code>add_argument</code> method takes another optional argument <code>choices</code>, which should be a <code>Sequence</code> of valid values for the argument.</p> <p>We can use our <code>currency_space</code> to define the valid values to avoid hard-coding any currencies in our application:</p> <pre><code>parser.add_argument(\n    \"from_currency\",\n    metavar=\"&lt;from_currency&gt;\",\n    choices=currency_space.currencies,\n    help=f\"\"\"The case-insensitive ISO 4217 aplphabetic currency code\n    of the &lt;amount&gt;. Accepted values: {currency_space.currencies}.\"\"\",\n)\n\nparser.add_argument(\n    \"to_currency\",\n    metavar=\"&lt;to_currency&gt;\",\n    choices=currency_space.currencies,\n    help=f\"\"\"The case-insensitive ISO 4217 alphabetic currency code\n    to convert the &lt;amount&gt; to. Accepted values: {currency_space.currencies}.\"\"\",\n)\n</code></pre> <p>The <code>currencies</code> of our <code>currency_space</code> are of course the valid currency codes that we have forex rates for, so now, if we rerun with these changes, we'll see that passing in bad input for the <code>&lt;from_currency&gt;</code> or <code>&lt;to_currency&gt;</code> arguments, such as <code>\"10 bad USD\"</code> or <code>\"10 USD bad\"</code> gives an appropriate error message and doesn't crash our prompt.</p> <p>However, we have another problem. Now if we provide a lower-case currency code, it is considered invalid input, even if the currency code is supported by our app. This didn't happen when we were using the values directly because linearmoney forces currency codes to upper case whenever they are used as strings for convenience, but the <code>choices</code> option for <code>add_argument</code> compares strings literally and never passes them into a linearmoney function if they don't match. We can solve this by providing a <code>type</code> function to the <code>&lt;from_currency&gt;</code> and <code>&lt;to_currency&gt;</code> arguments that forces the argument to upper-case:</p> <pre><code>def _upper_code(currency_code: str) -&gt; str:\n    \"\"\"Ensure the currency code is uppercase.\"\"\"\n\n    return currency_code.upper()\n\n\nparser.add_argument(\n    \"from_currency\",\n    metavar=\"&lt;from_currency&gt;\",\n    type=_upper_code,\n    choices=currency_space.currencies,\n    help=f\"\"\"The case-insensitive ISO 4217 aplphabetic currency code\n    of the &lt;amount&gt;. Accepted values: {currency_space.currencies}.\"\"\",\n)\n\nparser.add_argument(\n    \"to_currency\",\n    metavar=\"&lt;to_currency&gt;\",\n    type=_upper_code,\n    choices=currency_space.currencies,\n    help=f\"\"\"The case-insensitive ISO 4217 alphabetic currency code\n    to convert the &lt;amount&gt; to. Accepted values: {currency_space.currencies}.\"\"\",\n)\n</code></pre> <p>At this point, our <code>converter.py</code> script should be complete, and you should be able to play around with it to convert different currencies and amounts as well as see how it handles various invalid inputs.</p>"},{"location":"quickstart.html#complete-script","title":"Complete Script","text":"<pre><code>#!/usr/bin/python\n\n\"\"\"Interactive commandline script for converting currencies.\n\nConverts &lt;amount&gt; of &lt;from_currency&gt; to &lt;to_currency&gt;\n\nUsage: [-h|--help] &lt;amount&gt; &lt;from_currency&gt; &lt;to_currency&gt;\n\"\"\"\n\nif __name__ != \"__main__\":\n    raise ImportError(\"This is a standalone script and should not be imported.\")\n\nimport decimal\nimport argparse\nimport time\nimport urllib.request\nimport json\n\nimport linearmoney as lm\n\n\ndef request_rates() -&gt; dict:\n    \"\"\"Request the latest rates from theforexapi.com and\n    return them as a dict.\"\"\"\n\n    print(\"Fetching latest forex rates from theforexapi.com...\")\n    print(\"Waiting 2 seconds to comply with api rate limits...\")\n    time.sleep(2)  # Respect API rate limits.\n    url = \"https://theforexapi.com/api/latest\"\n    with urllib.request.urlopen(url) as response:\n        rate_dict = json.loads(response.read().decode(\"utf-8\"))\n        return rate_dict\n\n\nforex_vector = lm.vector.forex(request_rates())\ncurrency_space = lm.vector.space(forex_vector)\n\n\ndef _upper_code(currency_code: str) -&gt; str:\n    \"\"\"Ensure the currency code is uppercase.\"\"\"\n\n    return currency_code.upper()\n\n\ndef _error_decimal(amount: str) -&gt; decimal.Decimal:\n    \"\"\"Wrapper function that validates input as a decimal-compatible value.\"\"\"\n\n    try:\n        return decimal.Decimal(amount)\n    except decimal.InvalidOperation:\n        raise argparse.ArgumentTypeError(f\"Invalid numeric string '{amount}'\")\n\n\nparser = argparse.ArgumentParser(\n    prog=\"Currency Converter--&gt;\",\n    description=\"Convert &lt;amount&gt; of &lt;from_currency&gt; to &lt;to_currency&gt;\",\n    epilog=\"Use ctrl+c to exit/quit.\",\n)\n\nparser.add_argument(\n    \"amount\",\n    metavar=\"&lt;amount&gt;\",\n    type=_error_decimal,\n    help=\"\"\"The monetary value to convert from one currency to another.\n    Must be convertable to Python's decimal.Decimal type. E.g. 100, 100.0,\n    1E+2, etc...\"\"\",\n)\n\nparser.add_argument(\n    \"from_currency\",\n    metavar=\"&lt;from_currency&gt;\",\n    type=_upper_code,\n    choices=currency_space.currencies,\n    help=f\"\"\"The case-insensitive ISO 4217 aplphabetic currency code\n    of the &lt;amount&gt;. Accepted values: {currency_space.currencies}.\"\"\",\n)\n\nparser.add_argument(\n    \"to_currency\",\n    metavar=\"&lt;to_currency&gt;\",\n    type=_upper_code,\n    choices=currency_space.currencies,\n    help=f\"\"\"The case-insensitive ISO 4217 alphabetic currency code\n    to convert the &lt;amount&gt; to. Accepted values: {currency_space.currencies}.\"\"\",\n)\n\nwhile True:\n    readline = input(\"Currency Converter--&gt; \")\n    raw_args = readline.split()\n    try:\n        args = parser.parse_args(raw_args)\n    except SystemExit:\n        # We want to show the error, but not kill the interactive prompt.\n        pass\n    else:\n        asset_vector = lm.vector.asset(args.amount, args.from_currency, currency_space)\n        converted_value = lm.vector.evaluate(\n            asset_vector, args.to_currency, forex_vector\n        )\n        to_currency = lm.data.currency(args.to_currency)\n        rounded_value = lm.scalar.roundas(converted_value, to_currency)\n        result = lm.scalar.l10n(rounded_value, to_currency, lm.data.system_locale())\n        print(result)\n</code></pre>"},{"location":"quickstart.html#conclusion","title":"Conclusion","text":"<p>In this tutorial, we learned how to use linearmoney to create forex and asset vectors, evaluate/convert monetary amounts as a specific currency, and format a numeric value using the local currency format.</p> <p>These functions can do a lot more than this though. To get a better idea of how to integrate linearmoney with an application, take a look at the api documentation for the <code>l10n</code>, <code>roundas</code>, <code>currency</code>, and <code>locale</code> functions and change the output to display the currency in the international format, as a cash value, or using a custom format of your own creation.</p>"},{"location":"recipes.html","title":"Useful Recipes","text":"<p>This document gives examples of patterns for solving common problems with the linearmoney library that may not be obvious to a programmer who is not familiar with all of the library's features.</p>"},{"location":"recipes.html#reducing-verbosity-with-partial-application","title":"Reducing Verbosity with Partial Application","text":"<p>The linearmoney library has a functional/procedural API that makes all operations explicit, which makes programs easier to read and test, but it is very verbose when compared with more idiomatic OO Python, so some users may want to reduce this verbosity where possible.</p> <p>Partial application can help us here. Most explanations of partial application are very confusing, but practically speaking, it just means that we bind a specific value to a specific argument of a function and return a new function that has the same signature without the bound argument. You can think of it like setting a new default value for an argument and not allowing it to be changed from that point forward.</p> <p>The most obvious use of partial application for the linearmoney library is to eliminate the need to provide a currency space whenever we create an Asset Vector. This is generally safe for most applications since even if the forex rates change over time, the currencies the application supports generally don't, but if the supported currencies are determined dynamically, this technique should not be used.</p> <p>Here's what it looks like:</p> <pre><code>&gt;&gt;&gt; import functools\n&gt;&gt;&gt; import linearmoney as lm\n&gt;&gt;&gt; fo = lm.vector.forex({\"base\": \"usd\", \"rates\": {}})\n&gt;&gt;&gt; sp = lm.vector.space(fo)\n&gt;&gt;&gt; mkasset = functools.partial(lm.vector.asset, currency_space=sp)\n</code></pre> <p>Now, we can just import <code>mkasset</code>, and use it like so:</p> <pre><code>&gt;&gt;&gt; mkasset(10, \"usd\")\nMoneyVector('10',)\n</code></pre> <p>The <code>functools.partial</code> function takes a function and args/kwargs for that function and binds the values provided to those args/kwargs, so the new <code>mkasset</code> function is the same as calling <code>lm.vector.asset</code> with <code>currency_space=sp</code>, but we can't specify the currency space.</p> <p>This has advantages and drawbacks. On the one hand, it eliminates the possibility of passing in the wrong currency space to an asset, which would result in vector calculations between two different currency spaces at runtime, which is an exception. On the other hand, it means that we can't specify the currency space for different assets, so in more complex applications that need to deal with different sets of currencies or dynamic currencies, this won't work.</p> <p>One nice thing about FP as opposed to OOP is that we're working with immutable types, so even if we use this pattern to simplify the creation of Asset Vectors in the common case, we can still call the <code>lm.vector.asset</code> function directly to get vectors in different currency spaces.</p> <p>Also, if the requirements of our application are such that we need to support multiple distinct currency spaces, we can use this pattern to create separate functions for easily creating Asset Vectors in specific currency spaces without having to worry about passing the actual currency space around:</p> <pre><code>&gt;&gt;&gt; fo_europe = lm.vector.forex({\"base\": \"eur\", \"rates\": {\"gbp\": 0.8, \"usd\": 0.4}})\n&gt;&gt;&gt; sp_europe = lm.vector.space(fo_europe)\n&gt;&gt;&gt; euasset = functools.partial(lm.vector.asset, currency_space=sp_europe)\n&gt;&gt;&gt; fo_asia = lm.vector.forex({\"base\": \"jpy\", \"rates\": {\"cny\": 0.05, \"krw\": 10, \"inr\": 0.5}})\n&gt;&gt;&gt; sp_asia = lm.vector.space(fo_asia)\n&gt;&gt;&gt; asiaasset = functools.partial(lm.vector.asset, currency_space=sp_asia)\n&gt;&gt;&gt; euasset(10, \"usd\")\nMoneyVector('0', '0', '10')\n&gt;&gt;&gt; euasset(10, \"usd\") + euasset(10, \"eur\")\nMoneyVector('10', '0', '10')\n&gt;&gt;&gt; asiaasset(100, \"jpy\")\nMoneyVector('0', '0', '100', '0')\n&gt;&gt;&gt; asiaasset(100, \"jpy\") + asiaasset(100, \"krw\")\nMoneyVector('0', '0', '100', '100')\n&gt;&gt;&gt; euasset(10, \"usd\") + asiaasset(100, \"jpy\")\nTraceback (most recent call last):\n    ...\nlinearmoney.exceptions.SpaceError: MoneyVectors must be in the same space.\n</code></pre> <p>This gives us good error handling when we mix currencies that violate our application requirements with a lighter syntax at the callsite.</p> <p>Because all of the data types returned by functions in the linearmoney library are immutable, we can use partial application pretty much anywhere to create semantic interfaces without complicated dependencies or internal state.</p>"},{"location":"recipes.html#single-currency-application","title":"Single-Currency Application","text":"<p>With most libraries/frameworks for working with money, multi-currency amounts are not supported, so a monetary value is created like this:</p> <pre><code>Money(10, \"usd\")\n</code></pre> <p>However, with linearymoney, multi-currency is built-in, so to create a strictly single-currency application, we need to explicitly specify that our application only supports one currency.</p> <p>We do that by using a one-dimensional currency space.</p> <p>The standard way to create a single-currency amount is:</p> <pre><code>&gt;&gt;&gt; import linearmoney as lm\n&gt;&gt;&gt; fo = lm.vector.forex({\"base\": \"usd\", \"rates\": {}})\n&gt;&gt;&gt; sp = lm.vector.space(fo)\n&gt;&gt;&gt; lm.vector.asset(10, \"usd\", sp)\nMoneyVector('10',)\n</code></pre> <p>This is actually much safer and easier to work with in complex multi-currency applications, but in the simple case where the application is single-currency and just needs access to currency formatting and a simple <code>Money</code> type, this can be very unpleasant to use.</p> <p>See the Reducing Verbosity section for ideas on how to simplify this syntax for single-currency applications.</p>"}]}